#!/usr/bin/env python
#
# Code Challenge for Mark Gerolimatos
# (SF Movie Database)
# mark@gerolimatos.com
# 650 703-4774
# (c) Mark Gerolimatos, save for code borrowed and credited
#
# October, 2014
#

from BaseImport import *
from simplecache import *
import urllib
import requests
import json

# San Francisco region boxes: these are used to determine if a Google suggestion
# was at least in the ballpark. It's possible that they would suck given that
# the data we are using is quite sketch. You will note for instance that The Google
# is absolutely CERTAIN that Mission San Juan Buatista is next to AT&T Park, as
# it is on an intersection with the same names as streets in SF. In this case,
# the box wouldn't help, but if The Google DIDN'T do that, the point would be
# dropped off
#
# For more info, see this link:
# https://developers.google.com/maps/documentation/embed/guide
#

class BoundingBox:
  def __init__(self, n, s, e, w, name=Default) :
    if name is Default:
      name = "San Francisco"

    self.north = n
    self.south = s
    self.east = e
    self.west = w
    self.name = name

  # If within, returns the string name
  def within(self, lat, lon) :
    if (self.north >= lat and self.south <= lat
        and
        self.east >= lon and self.west <= lon) :
      # Need to do this to prevent needless generation of string
      if (ISLEVEL(1)) :INFOPRINT("%s: contains point <%f,%f>"%(self.name, lat, lon),1)
      return self.name

    return None


class SFBounds :
  # 7x7 mile city, including Alcatraz and Treasure Island/YBI
  cityWest = -122.52
  cityEast = -122.35
  cityNorth = 37.835
  citySouth = 37.7

  # SFO (which is part of San Francisco, so don't speed near a SFPD car there)
  sfoEast = -122.35
  sfoWest = -122.402
  sfoNorth = 37.644444
  sfoSouth = 37.6

  cityProper = BoundingBox(cityNorth,
                           citySouth,
                           cityEast,
                           cityWest,
                           "City Limits")

  sfo = BoundingBox( sfoNorth,
                     sfoSouth,
                     sfoEast,
                     sfoWest,
                     "SF International (SFO)")

  @staticmethod
  def within(lat, lon) :
    retval = SFBounds.cityProper.within(lat=lat, lon=lon)
    if (retval) :
      return retval
    return SFBounds.sfo.within(lat=lat, lon=lon)

#
#
# The Google Map Geolocation interface itself. Note that we do not 
# use pre-encoded Maps, as the performance of the dynamic Map/Marker
# API is good enough for these purposes, and that adding in account
# state would unecessarily complicate this demo. If map performance is
# thought too slow, then indeed a map could be generated by the server
# 
#
class GoogleMapInterface :
  # We will cache our GoogleMap interface calls to keep them from charging
  # us too much money. Note that uncertain results (such as having more than
  # one result) will be cahced for a much shorter period of time.
  # Items in the cache will go away after 10 days
  # ExpiringCaches are threadsafe
  cache = ExpiringCache(864000)

  urlformat = "http://maps.googleapis.com/maps/api/geocode/json?address=%s"

  def __init__(self) :
    self.decoder = json.JSONDecoder()
    pass

  # Returns a dict of:
  # latitude: floating point
  # longitude: floating point
  # cityRegion: one of either "City Limits" or a string specifying SFO
  # If region is NOT within city limits, cityRegion is "None"
  # On any error, will set a field named "errmsg"
  def geoLookup(self, locationString, urlencoded=True) :
    if locationString is None:
      return None
    locationString = str(locationString)

    # Url decode our string, tack on SF, CA (if needed), and encode back up
    # Note that we have to tack on SF so that The Google doesn't return results
    # in Costa Rica
    if (urlencoded) :
      locationString = UrlEncoder.decode(locationString)
    # Having "SF, CA" and "San Francisco, CA", etc. does not seem to hurt The Google's
    # results, and actually seems to help it somewhat.
    if (not re.search(r"san francisco,?\s+ca", locationString, re.I)) :
      locationString += " San Francisco, CA"
    locationString = UrlEncoder.encode(locationString)

    # Do a cache lookup first
    retval = GoogleMapInterface.cache.get(locationString)
    if (retval) :
      return retval

    url = "http://maps.googleapis.com/maps/api/geocode/json?address=%s"%locationString
    try:
      # It is suggested to wait a little more than multiples of 3 seconds, so
      # as not to conflict with an internal TCP timer
      response = requests.get(url, timeout=(6.05, 22))
    except Exception as e:
      INFOPRINT("Error code %d from url \"%s\""%(response.status_code,url))
      return { 'errmsg' : str(e) }
    if (response.status_code < 200 or response.status_code >= 300) :
      INFOPRINT("Error code %d from url \"%s\""%(response.status_code,url))
      return { 'errmsg' : "GoogleMaps request failed" }
    dic = self.decoder.decode(response.content)
    try:
      resultList = dic['results']
      retval = dict()
      if (resultList) :
        # If this isn't here, we will throw an exception and the request will fail.
        lat = resultList[0]['geometry']['location']['lat']
        lon = resultList[0]['geometry']['location']['lng']
        name = SFBounds.within(lat=lat, lon=lon)
        retval['latitude'] = lat
        retval['longitude'] = lon
        retval['name'] = name
      # If only one entry, then assume that we've got a pretty good result.
      # So just leave it be, let it be
      if dic.get('error_message') :
        retval['errmsg'] = dic.get('error_message')
      else :
        if (len(resultList) == 1) :
          # If only one result, then cache for the default (10 days)
          ttl = None
        else :
          # Otherwise, only let the result be cached for a day, as there are
          # apparently many different entries possible for this guy
          ttl = 86400
        GoogleMapInterface.cache.put(locationString, retval, ttlSeconds=ttl)
      return retval
    except Exception as e:
      INFOPRINT("GEO LOOKUP EXCEPTION! = %s"%str(e), 5)
      # Leave the cache alone
      return { 'errmsg' : str(e) }


  @staticmethod
  #
  #
  # Take a title for the map, a list of markers to drop in the map, and three
  # varargs: 
  # searchCommand, which will be parroted back by the javascript on
  #    various link clicks,
  # infoWIndowTitle, which will be what will be in the popup info window. Can be unset
  # infoWIndowUP, which contains the name of the marker that the info window will be
  # stuck on. This is typically used for single-marker searches only
  #
  # Returns a list of strings that should be output'd to create the necessary map
  # Taken pretty much verbatim from:
  # https://developers.google.com/maps/documentation/javascript/examples/marker-simple
  # Strictly speaking, doesn't actually interact with The Google, but it DOES use many
  # concepts from the Google API when generating Javascript and HTML. And s exists here.
  # Caller's responsibility to bracket with <head></head>
  #
  #
  def mapHeader(title, listOfMarkers, **keywordargs) :

    searchCommand = keywordargs.get('searchCmd')
    infoWindowTitle = keywordargs.get('infowindowtitle')
    infoWindowUp = keywordargs.get('infoup')

    # This writes out the correct javascript headers
    #response.write("<script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=false"></script>\n")
    outlist = [
    '<meta name="viewport" content="initial-scale=1.0, user-scalable=no">',
    '<meta charset="utf-8">',
    "<title>%s</title>"%title,
    '<style>',
    ' html, body, #map-canvas {',
    '   height: 100%;',
    '   margin: 0px;',
    '   padding: 0px',
    ' }',
    '</style>',
    '<script src="https://maps.googleapis.com/maps/api/js?v=3.exp"></script>'
    ]

    # Now generate code for the markers

    # Find maximum and minimum latitude and longitude, then pick the middle to
    # center in on
    maxlat = -90
    maxlon = -180
    minlat = 90
    minlon = 180

    markernum = 0
    markerstrings = list()
    # No markers? Show SF proper
    if not listOfMarkers:
      
      minlon = SFBounds.cityWest
      maxlon = SFBounds.cityEast
      maxlat = SFBounds.cityNorth
      minlat = SFBounds.citySouth
    else :
    #{
      for marker in listOfMarkers :
      #{
        lat = marker['latitude']
        lon = marker['longitude']
        if (maxlat < lat) : maxlat = lat
        if (maxlon < lon) : maxlon = lon
        if (minlat > lat) : minlat = lat
        if (minlon > lon) : minlon = lon
        markerstrings.extend([
                             "var latlng%d = new google.maps.LatLng(%f, %f);"%(markernum, lat,lon),
                             "var marker%d = new google.maps.Marker({"%markernum ,
                             "    position: latlng%d,"%markernum ,
                             "    map: locationmap," ,
                             "    icon: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png'," 
                            ])
        if (searchCommand) :
          mname = UrlEncoder.encode(marker['name'])
          markerstrings.extend([
                             "    title: \"%s\","%marker['name'],
                             "    url: '/?cmd=%s&input=%s'"%(searchCommand,mname),
                             "});",
                             "marker%d.setMap(locationmap);"%markernum
                             ])
        else :
          markerstrings.extend([
                             "    title: \"%s\""%marker['name'] ,
                             "});",
                             "marker%d.setMap(locationmap);"%markernum
                             ])

        # If there is a search command, issue the "click" function
        if (searchCommand) :
          markerstrings.append(
                             "google.maps.event.addListener(marker%d, 'click', function(){window.location.href = this.url;});"%markernum)
          moutfunc = ("google.maps.event.addListener(marker%d, 'mouseout', function(){this.setIcon('http://maps.google.com/mapfiles/ms/icons/red-dot.png');"%markernum) + ("infowindow.close();" if not infoWindowUp else "") + "});"
          moinfunc = ("google.maps.event.addListener(marker%d, 'mouseover', function(){this.setIcon('http://maps.google.com/mapfiles/ms/icons/green-dot.png');"%markernum) + ("infowindow.setContent(\"%s\");infowindow.open(locationmap,marker%d);"%(marker['name'],markernum) if not infoWindowUp else "") + "});"
          markerstrings.extend([moutfunc, moinfunc])

        markernum += 1
      #}
    #}

    centerlat = (maxlat+minlat)/2
    centerlon = (maxlon+minlon)/2

    outlist.extend([
      "<script>",
      "function initialize() {",
      "var infowindow = new google.maps.InfoWindow();",
      "var centerpoint = new google.maps.LatLng(%f, %f);"%(centerlat,centerlon),
      "var settings = {",
      " zoom: 4,",
      " center: centerpoint",
      "}",
      'var locationmap = new google.maps.Map(document.getElementById("map-canvas"), settings);',
      "var ne = new google.maps.LatLng(%f,%f);"%(maxlat,maxlon),
      "var sw = new google.maps.LatLng(%f,%f);"%(minlat,minlon),
      "var boundbox = new google.maps.LatLngBounds(sw, ne);",
      "locationmap.fitBounds(boundbox);"
    ])
    # Now create the marker strings
    if markerstrings:
      outlist.extend(markerstrings)

    if (infoWindowUp) :
      outlist.extend([
        "infowindow.setContent('%s');"%infoWindowTitle,
        "infowindow.open(locationmap,%s);"%infoWindowUp
      ])

    outlist.extend([
      "}", # End initialize
      "google.maps.event.addDomListener(window, 'load', initialize);"
    ])

    outlist.extend([
      "</script>"
    ])
    return outlist
